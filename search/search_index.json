{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"Overview","text":"Foxy Contexts  Build MCP Servers Declaratively in Golang <p> Features \ud83e\udd8a   Tool Example \ud83e\udd8a   Docs \ud83e\udd8a   Sources </p> <p>Foxy contexts is a Golang library for building context servers supporting Model Context Protocol.</p> <p>This library only supports server side of the protocol. Using it you can build context servers using declarative approach, by defining tools, resources and prompts and then registering them with your app.Builder, which is using uber's fx App under the hood and you can inject into its container as well.</p> <p>With this approach you can easily colocate call/read/get logic and definitions of your tools/resources/prompts in a way that every tool/resource/prompt is placed in a separate place, but related code is colocated.</p>"},{"location":"#features","title":"Features","text":"<p>Here is list of features that are implemented and planned:</p> <ul> <li> Base (lifecycle/ping)<ul> <li> Progress (planned)</li> </ul> </li> <li> Transports<ul> <li> Stdio Transport</li> <li> SSE Transport</li> </ul> </li> <li> Tools<ul> <li> Package toolinput helps define tools input schema and validate arriving input</li> </ul> </li> <li> Resources<ul> <li> Resources - static</li> <li> Resources - dynamic via Resource Providers</li> <li> Resources - dynamic via Resource Templates (planned)</li> <li> Resource Templates completion (planned)</li> <li> Resource subscriptions</li> </ul> </li> <li> Prompts</li> <li> Prompts Completion</li> <li> Functional Testing package foxytest</li> <li> Simple building of your MCP server with the power of Dependency Injection</li> <li> Logging via MCP (planned)</li> <li> Sampling (planned)</li> <li> Roots (planned)</li> <li> Pagination (planned)</li> <li> Notifications list_changed (planned)</li> <li> Testing - functional tests with foxytest package</li> </ul> <p>Check docs and examples to know more.</p>"},{"location":"#tool-example","title":"Tool Example","text":"<p>For example try following</p> <p><pre><code>git clone https://github.com/strowk/foxy-contexts\ncd foxy-contexts/examples/list_current_dir_files_tool\nnpx @modelcontextprotocol/inspector go run main.go\n</code></pre> , then once inspector is started in browser open http://localhost:5173 and try to use list-current-dir-files.</p> <p>Here's the code of that example from examples/list_current_dir_files_tool/main.go (in real world application you would probably want to split it into multiple files):</p> <pre><code>package main\n\nimport (\n    \"fmt\"\n    \"os\"\n\n    \"github.com/strowk/foxy-contexts/pkg/app\"\n    \"github.com/strowk/foxy-contexts/pkg/fxctx\"\n    \"github.com/strowk/foxy-contexts/pkg/mcp\"\n    \"github.com/strowk/foxy-contexts/pkg/stdio\"\n    \"go.uber.org/fx\"\n    \"go.uber.org/fx/fxevent\"\n    \"go.uber.org/zap\"\n)\n\n// This example defines list-current-dir-files tool for MCP server, that prints files in the current directory\n// , run it with:\n// npx @modelcontextprotocol/inspector go run main.go\n// , then in browser open http://localhost:5173\n// , then click Connect\n// , then click List Tools\n// , then click list-current-dir-files\n\n// NewListCurrentDirFilesTool defines a tool that lists files in the current directory\nfunc NewListCurrentDirFilesTool() fxctx.Tool {\n    return fxctx.NewTool(\n        // This information about the tool would be used when it is listed:\n        &amp;mcp.Tool{\n            Name:        \"list-current-dir-files\",\n            Description: Ptr(\"Lists files in the current directory\"),\n            InputSchema: mcp.ToolInputSchema{\n                Type:       \"object\",\n                Properties: map[string]map[string]interface{}{},\n                Required:   []string{},\n            },\n        },\n\n        // This is the callback that would be executed when the tool is called:\n        func(args map[string]interface{}) *mcp.CallToolResult {\n            files, err := os.ReadDir(\".\")\n            if err != nil {\n                return &amp;mcp.CallToolResult{\n                    IsError: Ptr(true),\n                    Meta:    map[string]interface{}{},\n                    Content: []interface{}{\n                        mcp.TextContent{\n                            Type: \"text\",\n                            Text: fmt.Sprintf(\"failed to read dir: %v\", err),\n                        },\n                    },\n                }\n            }\n            var contents []interface{} = make([]interface{}, len(files))\n            for i, f := range files {\n                contents[i] = mcp.TextContent{\n                    Type: \"text\",\n                    Text: f.Name(),\n                }\n            }\n\n            return &amp;mcp.CallToolResult{\n                Meta:    map[string]interface{}{},\n                Content: contents,\n                IsError: Ptr(false),\n            }\n        },\n    )\n}\n\nfunc main() {\n    app.\n        NewBuilder().\n        // adding the tool to the app\n        WithTool(NewListCurrentDirFilesTool).\n        // setting up server\n        WithName(\"list-current-dir-files\").\n        WithVersion(\"0.0.1\").\n        WithTransport(stdio.NewTransport()).\n        // Configuring fx logging to only show errors\n        WithFxOptions(fx.Provide(func() *zap.Logger {\n                cfg := zap.NewDevelopmentConfig()\n                cfg.Level.SetLevel(zap.ErrorLevel)\n                logger, _ := cfg.Build()\n                return logger\n            }),\n            fx.Option(fx.WithLogger(\n                func(logger *zap.Logger) fxevent.Logger {\n                    return &amp;fxevent.ZapLogger{Logger: logger}\n                },\n            )),\n        ).\n        Run()\n}\n\nfunc Ptr[T any](v T) *T {\n    return &amp;v\n}\n</code></pre>"},{"location":"app_builder/","title":"app.Builder","text":"<p>app.Builder is a builder around uber's fx that combines fx DI capabilities with foxy-contexts MCP server implementation and gives simple interface to combine your MCP primitives into a single standalone application.</p>"},{"location":"app_builder/#usage","title":"Usage","text":"<p>Simple example of wrapping one tool into an application, then running it with stdio transport:</p> <pre><code>func main() {\n    app.\n        NewBuilder().\n        // adding the tool to the app\n        WithTool(NewGreatTool).\n        // setting up server\n        WithName(\"great-tool-server\").\n        WithVersion(\"0.0.1\").\n        WithTransport(stdio.NewTransport()).\n        // Configuring fx logging to only show errors\n        WithFxOptions(\n            fx.Provide(func() *zap.Logger {\n                cfg := zap.NewDevelopmentConfig()\n                cfg.Level.SetLevel(zap.ErrorLevel)\n                logger, _ := cfg.Build()\n                return logger\n            }),\n            fx.Option(fx.WithLogger(\n                func(logger *zap.Logger) fxevent.Logger {\n                    return &amp;fxevent.ZapLogger{Logger: logger}\n                },\n            )),\n        ).Run()\n}\n</code></pre>"},{"location":"app_builder/#providing-additional-server-options","title":"Providing additional server options","text":"<p>Normally app.Builder preconfigure server for you, but you can provide additional server options to the application by using <code>WithExtraServerOptions</code> option.</p> <p>Say, for example this would make server to turn on logging to stderr:</p> <pre><code>WithExtraServerOptions(server.LoggerOption{\n    Logger: foxyevent.NewSlogLogger(slog.New(slog.NewTextHandler(os.Stderr, &amp;slog.HandlerOptions{\n        Level: slog.LevelDebug,\n    }))).WithLogLevel(slog.LevelInfo),\n})\n</code></pre>"},{"location":"prompts/","title":"Prompts","text":"<p>Prompts enable servers to define reusable prompt templates and workflows that clients can easily surface to users and LLMs</p> <p>MCP prompts is a concept of MCP servers. Server should list prompts when requested with method <code>prompts/list</code> and retrieve when requested with method <code>prompts/get</code>.</p> <p>Foxy Contexts allows easy way to define a prompt and register it within fx DI container.</p>"},{"location":"prompts/#newprompt","title":"NewPrompt","text":"<p>In order to create new prompt you shall use <code>fxctx.NewPrompt</code> function. It accepts prompt name, description and function that would be called when prompt is called.</p> <pre><code>func NewGreatPrompt() fxctx.Prompt {\n    return fxctx.NewPrompt(\n        // This information about the prompt would be used when it is listed:\n        mcp.Prompt{\n            Name:        \"my-great-prompt\",\n            Description: Ptr(\"Doing something great\"),\n            Arguments: []mcp.PromptArgument{\n                {\n                    Description: Ptr(\"An argument for the prompt\"),\n                    Name:        \"arg-1\",\n                    Required:    Ptr(true),\n                },\n            },\n        },\n        // This is the callback that would be executed when the prompt/get is requested:\n        func(req *mcp.GetPromptRequest) (*mcp.GetPromptResult, error) {\n            description := \"Prompting to do something great\"\n            return &amp;mcp.GetPromptResult{\n                Description: &amp;description,\n                Messages: []mcp.PromptMessage{\n                    {\n                        Content: mcp.TextContent{\n                            Type: \"text\",\n                            Text: \"Would you like to do something great?\",\n                        },\n                        Role: mcp.RoleUser,\n                    },\n                },\n            }, nil\n        },\n    )\n}\n</code></pre>"},{"location":"prompts/#register-prompt-and-start-server","title":"Register prompt and start server","text":"<pre><code>func main() {\n    app.\n        NewBuilder().\n        // adding the tool to the app\n        WithPrompt(NewGreatPrompt).\n        // setting up server\n        WithName(\"great-tool-server\").\n        WithVersion(\"0.0.1\").\n        WithTransport(stdio.NewTransport()).\n        // Configuring fx logging to only show errors\n        WithFxOptions(\n            fx.Provide(func() *zap.Logger {\n                cfg := zap.NewDevelopmentConfig()\n                cfg.Level.SetLevel(zap.ErrorLevel)\n                logger, _ := cfg.Build()\n                return logger\n            }),\n            fx.Option(fx.WithLogger(\n                func(logger *zap.Logger) fxevent.Logger {\n                    return &amp;fxevent.ZapLogger{Logger: logger}\n                },\n            )),\n        ).Run()\n}\n</code></pre>"},{"location":"prompts/#examples","title":"Examples","text":"<p>Check out complete example of MCP Server with prompt:</p> <ul> <li>simple_prompt - provides a very basic prompt</li> <li>list_k8s_namespaces_prompt - provides a prompt listing k8s namespaces</li> </ul>"},{"location":"resources/","title":"Resources","text":"<p>Resources are a core primitive in the Model Context Protocol (MCP) that allow servers to expose data and content that can be read by clients and used as context for LLM interactions.</p> <p>MCP resources is a concept of MCP servers. Server should list resources when requested with method <code>resources/list</code> and retrieve when requested with method <code>resources/read</code>.</p> <p>Servers also can provide dynamic resources using templates by listing them via <code>resources/templates/list</code>, however this feature is not yet supported in Foxy Contexts.</p> <p>In Foxy Contexts there are two ways to include resources in your server:</p> <ul> <li>using <code>fxctx.NewResource</code> to define static resources</li> <li>using <code>fxctx.NewResourceProvider</code> to define resource providers</li> </ul> <p>Approach with resource provider is more flexible and allows to provide resources dynamically, however all such resources would be still included in response for <code>resources/list</code>, in contrasts to concept of templates (which are not yet supported).</p>"},{"location":"resources/#newresource","title":"NewResource","text":"<p>In order to create new static resource you shall use <code>fxctx.NewResource</code> function.</p> <pre><code>func NewGreatResource() fxctx.Resource {\n    return fxctx.NewResource(\n        mcp.Resource{\n            Name:        \"hello-world\",\n            Uri:         \"hello-world://hello-world\",\n            MimeType:    Ptr(\"application/json\"),\n            Description: Ptr(\"Hello World Resource\"),\n            Annotations: &amp;mcp.ResourceAnnotations{\n                Audience: []mcp.Role{\n                    mcp.RoleAssistant, mcp.RoleUser,\n                },\n            },\n        },\n        func(uri string) (*mcp.ReadResourceResult, error) {\n            return &amp;mcp.ReadResourceResult{\n                Contents: []interface{}{\n                    mcp.TextResourceContents{\n                        MimeType: Ptr(\"application/json\"),\n                        Text:     `{\"hello\": \"world\"}`,\n                        Uri:      uri,\n                    },\n                },\n            }, nil\n        },\n    )\n}\n</code></pre>"},{"location":"resources/#register-resources-and-start-server","title":"Register resources and start server","text":"<pre><code>func main() {\n    err := app.\n        NewBuilder().\n        // adding the resource to the app\n        WithResource(NewGreatResource).\n        // setting up server\n        WithName(\"my-mcp-server\").\n        WithVersion(\"0.0.1\").\n        WithTransport(stdio.NewTransport()).\n        // Configuring fx logging to only show errors\n        WithFxOptions(\n            fx.Provide(func() *zap.Logger {\n                cfg := zap.NewDevelopmentConfig()\n                cfg.Level.SetLevel(zap.ErrorLevel)\n                logger, _ := cfg.Build()\n                return logger\n            }),\n            fx.Option(fx.WithLogger(\n                func(logger *zap.Logger) fxevent.Logger {\n                    return &amp;fxevent.ZapLogger{Logger: logger}\n                },\n            )),\n        ).Run()\n\n    if err != nil {\n        log.Fatal(err)\n    }\n}\n</code></pre>"},{"location":"resources/#newresourceprovider","title":"NewResourceProvider","text":"<p>In order to create new resource provider that would be returning resources dynamically, you shall use <code>fxctx.NewResourceProvider</code> function. It would then take two functions - one in order to list resources and another to read them.</p> <pre><code>func NewGreatResourceProvider() fxctx.ResourceProvider {\n    return fxctx.NewResourceProvider(\n        // This is the callback that would be executed when the resources/list is requested:\n        func() ([]mcp.Resource, error) {\n            return []mcp.Resource{\n                {\n                    Name: \"my-great-resource-one\",\n                    Description: Ptr(\"Does something great\"),\n                    Uri: \"/resources/great/one\",\n                },\n            }, nil\n        },\n        //  This function reads the resource for a given uri to run when resources/read is requested:\n        func(uri string) (*mcp.ReadResourceResult, error) {\n\n            // you would probably be doing something more complicated here\n            // like reading from a database or calling an external service\n            // based on what you have parsed from the uri\n            if uri == \"/resources/great/one\" {\n                return &amp;mcp.ReadResourceResult{\n                    Contents: []interface{}{\n                        mcp.TextResourceContents{\n                            MimeType: Ptr(\"application/json\"),\n                            Text:     string(`{\"great\": \"resource\"}`),\n                            Uri:      uri,\n                        }\n                    },\n                }, nil\n            }\n\n            // this error would be wrapped in JSON-RPC error response\n            return nil, fmt.Errorf(\"resource not found\")\n        },\n    )\n}\n</code></pre>"},{"location":"resources/#examples","title":"Examples","text":"<p>Check out complete examples of MCP Servers with resources:</p> <ul> <li>k8s_contexts_resources - provides k8s contexts as resources</li> <li>hello_world_resource - provides one static very simple resource</li> <li>git_repository_resource - provides one static resource with information about git repository</li> </ul>"},{"location":"testing/","title":"Testing","text":""},{"location":"testing/#integration-testing-with-foxytest-using-mcp-cases-format","title":"Integration Testing with foxytest using MCP Cases format","text":"<p>In order to test your server, package <code>foxytest</code> is provided that allows you to easily start your server and test it using pre-defined JSON-RPC 2.0 messages.</p> <p><code>foxytest</code> currently only supports stdio transport.</p> <p>Here is an example how to setup integration tests:</p> <pre><code>import (\n    \"testing\"\n\n    \"github.com/strowk/foxy-contexts/pkg/foxytest\"\n)\n\nfunc TestWithFoxytest(t *testing.T) {\n    ts, err := foxytest.Read(\"testdata\")\n    if err != nil {\n        t.Fatal(err)\n    }\n    ts.WithExecutable(\"go\", []string{\"run\", \"main.go\"})\n    ts.WithLogging() // this adds logging to the test runner, you could see it if you run tests with -v flag\n    cntrl := foxytest.NewTestRunner(t)\n    ts.Run(cntrl)\n    ts.AssertNoErrors(cntrl)\n}\n</code></pre> <p>In folder <code>testdata</code>, you should have files with names ending on <code>_test.yaml</code>. These files should contain MCP Stories that would describe the test scenario. For example:</p> <pre><code>case: Empty tools list\nin_list_tools: {\"jsonrpc\":\"2.0\",\"method\":\"tools/list\",\"id\":1}\nout_no_tools: {\"jsonrpc\":\"2.0\",\"result\":{\"tools\":[]},\"id\":1}\n</code></pre> <p>This says that when client sends <code>tools/list</code> request, server should respond with empty list of tools.</p> <p>Tests could be single or multi-document YAML files. Each document should be in a valid MCP Cases format, that means it can have <code>case</code> property with name of the test case and any number of properties prefixed with <code>in</code> and <code>out</code>, which would represent JSON-RPC 2.0 messages sent from client to server (<code>in</code>) and from server to client (<code>out</code>).</p> <p>When you run the test by executing <code>go test</code>, the test runner will start your server (by running <code>go run main.go</code> in this case), connect to stdio transport and send the message under <code>in</code> property. </p> <p>It will then wait for the response from server and compare it with the message under <code>out</code> property. If message is matching JSON structure, it will pass the test, otherwise it will fail and would print the diff between expected and actual JSON's.</p> <p>If you need more information from test run, and have configured logging with <code>ts.WithLogging()</code> you can then use <code>verbose</code> flag when running the test: <code>go test -v</code>, you will then see the output like this:</p> <pre><code>=== RUN   TestWithFoxytest\n    testsuite.go:55: setting up test suite\n    testsuite.go:59: running command: go run main.go\n    testsuite.go:59: running 1 tests\n    testsuite.go:55: waiting for command to finish\n    testsuite.go:59: expecting output: {\"id\":1,\"jsonrpc\":\"2.0\",\"result\":{\"tools\":[]}}\n    testsuite.go:59: sending input: {\"id\":1,\"jsonrpc\":\"2.0\",\"method\":\"tools/list\"}\n    testsuite.go:59: output matches: {\"jsonrpc\":\"2.0\",\"result\":{\"tools\":[]},\"id\":1}\n    testsuite.go:55: tests done\n    testsuite.go:55: running after all\n    testsuite.go:55: stop executable\n    testsuite.go:55: finished reading output\n    testsuite.go:55: executable stopped\n--- PASS: TestWithFoxytest (1.39s)\n</code></pre> <p>When failed, package attempts to pretty print the diff between expected and actual JSON's, so you can quickly locate the issue.</p> <p>Here is an example of real world failing test:</p> <pre><code>    testsuite.go:54:\n          \"result\": {\n            \"content\": {\n              \"0\": {\n                \"text\": {\n                ^ value does not match the embedded regex:\n        expected to match: \"{\"name\":\"k3d-mcp-k8s-test-server-0\",\"status\":\"Active\",\"age\":\"/[\\\\d][sm]/\",\"createdAt\":\"/[\\\\d]{4}/-/[\\\\d]{2}/-/[\\\\d]{2}/T/[\\\\d]{2}/:/[\\\\d]{2}/:/[\\\\d]{2}/Z\"}\",\n                  but got: \"{\"name\":\"k3d-mcp-k8s-integration-test-server-0\",\"status\":\"Unknown\",\"age\":\"1m0s\"}\"\n</code></pre> <p>Output is not a valid JSON, it just attempts to show the difference at the right point in structure.</p>"},{"location":"testing/#using-regular-expressions-for-matching","title":"Using regular expressions for matching","text":"<p>Sometimes when you have dynamic values in your responses, you might want to use regular expressions to match them. You can do this by using <code>!!re</code> tag in your expected output. For example:</p> <pre><code>case: List tools\nin_list_tools: {\"jsonrpc\":\"2.0\",\"method\":\"tools/list\",\"id\":1}\nout_list_tools: {\"jsonrpc\":\"2.0\",\"result\":{\"tools\":[ { \"name\": !!re \"list-[a-z]+\" } ]},\"id\":1}\n</code></pre> <p>This example is somewhat oversimplified, in reality you would probably use <code>!!re</code> with timestamps, UUIDs or other dynamic values, rather than tool names. It does, however, demonstrate that strings with <code>!!re</code> tag would be treated as regular expressions and would be matched against actual values using regular expression matching instead of string equality.</p>"},{"location":"testing/#embedded-regular-expressions","title":"Embedded regular expressions","text":"<p>Embedded regular expression is just a regular expression that is embedded in a string. It is used to match a part of the string. For example:</p> <pre><code>case: List tools\nin_list_tools: {\"jsonrpc\":\"2.0\",\"method\":\"tools/list\",\"id\":1}\nout_list_tools: {\"jsonrpc\":\"2.0\",\"result\":{\"tools\":[ { \"name\": !!ere \"list-/[a-z]+/-tool\" } ]},\"id\":1}\n</code></pre> <p>Essentially <code>!!ere</code> allows you to treat most of the string as just regular string, but have a part (or parts) of it treated as regular expression. Everything inside slashes <code>/</code> would be treated as regular expression, here \"list-\" and \"-tool\" are regular strings, but <code>[a-z]+</code> is a regular expression that would match any lowercase letters non-empty string, so it would match \"list-abc-tool\", \"list-xyz-tool\" and so on.</p> <p>This approach allows you not to think how to escape regular expression syntax in the rest of your string and only match bits that you need to be dynamic.</p>"},{"location":"testing/#escaping-forward-slashes","title":"Escaping forward slashes","text":"<p>You do, however need to escape slashes <code>/</code> in places of your string where you want to use them, but not designate regular expression, for example: <code>\"url\": !! \"https:\\\\/\\\\/foxy-contexts.str4.io\\\\//[a-z]+/\"</code> would match <code>\"url\": \"https://foxy-contexts.str4.io/abc\"</code>. In here <code>\\\\/</code> is used to become <code>/</code> and <code>[a-z]+</code> is used to match any lowercase letters non-empty string. The reason why there are two backslashes <code>\\\\</code> is because in YAML strings backslash is an escape character, so to have a single backslash in the string you need to escape it with another backslash.</p>"},{"location":"testing/#examples","title":"Examples","text":"<p>See following examples with tests:</p> <ul> <li>examples/git_repository_resource/main_test.go</li> <li>examples/hello_world_resource/main_test.go</li> <li>examples/k8s_contexts_resources/main_test.go</li> <li>examples/list_current_dir_files_tool/main_test.go</li> </ul>"},{"location":"tools/","title":"Tools","text":"<p>Through tools, LLMs can interact with external systems, perform computations, and take actions in the real world.</p> <p>MCP tools is a concept of MCP servers. Server should list tools when requested with method <code>tools/list</code> and call when requested with method <code>tools/call</code>.</p> <p>Foxy Contexts allows easy way to define a tool and register it within fx DI container.</p>"},{"location":"tools/#newtool","title":"NewTool","text":"<p>In order to create new tool you shall use <code>fxctx.NewTool</code> function. It accepts tool name, description and function that would be called when tool is called.</p> <pre><code>func NewGreatTool() fxctx.Tool {\n    return fxctx.NewTool(\n        // This information about the tool would be used when it is listed:\n        &amp;mcp.Tool{\n            Name:        \"my-great-tool\",\n            Description: Ptr(\"The great tool\"),\n            InputSchema: mcp.ToolInputSchema{ // here we tell client what we expect as input\n                Type:       \"object\",\n                Properties: map[string]map[string]interface{}{},\n                Required:   []string{},\n            },\n        },\n\n        // This is the callback that would be executed when the tool is called:\n        func(args map[string]interface{}) *mcp.CallToolResult {\n            // here we can do anything we want\n            return &amp;mcp.CallToolResult{\n                Content: []interface{}{\n                    mcp.TextContent{\n                        Type: \"text\",\n                        Text: fmt.Sprintf(\"Sup\"),\n                    },\n                },\n            }\n        },\n    )\n}\n</code></pre>"},{"location":"tools/#register-tool-and-start-server","title":"Register tool and start server","text":"<pre><code>func main() {\n    app.\n        NewBuilder().\n        // adding the tool to the app\n        WithTool(NewGreatTool).\n        // setting up server\n        WithName(\"great-tool-server\").\n        WithVersion(\"0.0.1\").\n        WithTransport(stdio.NewTransport()).\n        // Configuring fx logging to only show errors\n        WithFxOptions(\n            fx.Provide(func() *zap.Logger {\n                cfg := zap.NewDevelopmentConfig()\n                cfg.Level.SetLevel(zap.ErrorLevel)\n                logger, _ := cfg.Build()\n                return logger\n            }),\n            fx.Option(fx.WithLogger(\n                func(logger *zap.Logger) fxevent.Logger {\n                    return &amp;fxevent.ZapLogger{Logger: logger}\n                },\n            )),\n        ).Run()\n}\n</code></pre>"},{"location":"tools/#using-toolinput-package","title":"Using toolinput package","text":"<p>In order to define input schema for your tool, you can use <code>toolinput</code> package. It allows you to define input schema and validate arriving input.</p> <p>Here is an example of creating schema, giving it to the tool and validating input:</p> <pre><code>    schema := toolinput.NewToolInputSchema(\n        toolinput.WithString(\"kubeconfig\", \"Path to kubeconfig file\"),\n    )\n\n    // Here we define a tool that lists k8s contexts using client-go\n    return fxctx.NewTool(\n        // This information about the tool would be used when it is listed:\n        &amp;mcp.Tool{\n            Name:        \"list-k8s-contexts\",\n            Description: Ptr(\"List Kubernetes contexts from configuration files such as kubeconfig\"),\n            InputSchema: schema.GetMcpToolInputSchema(),\n        },\n\n        // This is the callback that would be executed when the tool is called:\n        func(args map[string]interface{}) *mcp.CallToolResult {\n            input, err := schema.Validate(args)\n            if err != nil {\n                log.Printf(\"failed to validate input: %v\", err)\n                return &amp;mcp.CallToolResult{\n                    IsError: Ptr(true),\n                    Content: []interface{}{\n                        mcp.TextContent{\n                            Type: \"text\",\n                            Text: fmt.Sprintf(\"failed to validate input: %v\", err),\n                        },\n                    },\n                }\n            }\n\n            path := input.StringOr(\"kubeconfig\", \"\")\n            if path != \"\" {\n                os.Setenv(\"KUBECONFIG\", path)\n            }\n</code></pre>"},{"location":"tools/#examples","title":"Examples","text":"<p>Check out complete examples of MCP Servers with tools:</p> <ul> <li>list_current_dir_files_tool</li> <li>list_k8s_contexts_tool</li> </ul>"},{"location":"links/","title":"Links","text":""}]}