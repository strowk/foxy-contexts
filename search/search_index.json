{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"Overview","text":""},{"location":"#foxy-contexts","title":"Foxy Contexts","text":"<p>Foxy contexts is a library for building context servers supporting Model Context Protocol.</p> <p>This library only supports server side of the protocol. Using it you can build context servers using declarative approach, by defining tools, resources and prompts and then registering them within DI using uber's fx.</p> <p>With this approach you can easily colocate call/read/get logic and definitions of your tools/resources/prompts in a way that every tool/resource/prompt is placed in a separate place, but related code is colocated.</p> <p>Check docs and examples to know more.</p>"},{"location":"#tool-example","title":"Tool Example","text":"<p>For example try following</p> <p><pre><code>git clone https://github.com/strowk/foxy-contexts\ncd foxy-contexts/examples/list_current_dir_files_tool\nnpx @modelcontextprotocol/inspector go run main.go\n</code></pre> , then once inspector is started in browser open http://localhost:5173 and try to use list-current-dir-files.</p> <p>Here's the code of that example from examples/list_current_dir_files_tool/main.go (in real world application you would probably want to split it into multiple files):</p> <pre><code>package main\n\nimport (\n    \"context\"\n    \"fmt\"\n    \"os\"\n\n    \"github.com/strowk/foxy-contexts/pkg/fxctx\"\n    \"github.com/strowk/foxy-contexts/pkg/mcp\"\n    \"github.com/strowk/foxy-contexts/pkg/server\"\n    \"github.com/strowk/foxy-contexts/pkg/stdio\"\n    \"go.uber.org/fx\"\n    \"go.uber.org/fx/fxevent\"\n    \"go.uber.org/zap\"\n)\n\nfunc main() {\n    // This example defines list-current-dir-files tool for MCP server, that prints files in the current directory\n    // , run it with:\n    // npx @modelcontextprotocol/inspector go run main.go\n    // , then in browser open http://localhost:5173\n    // , then click Connect\n    // , then click List Tools\n    // , then click list-current-dir-files\n\n    fx.New(\n        // Here we define a tool that lists files in the current directory\n        fx.Provide(fxctx.AsTool(\n            func() fxctx.Tool {\n\n                return fxctx.NewTool(\n                    // This information about the tool would be used when it is listed:\n                    &amp;mcp.Tool{\n                        Name:        \"list-current-dir-files\",\n                        Description: Ptr(\"Lists files in the current directory\"),\n                        InputSchema: mcp.ToolInputSchema{\n                            Type:       \"object\",\n                            Properties: map[string]map[string]interface{}{},\n                            Required:   []string{},\n                        },\n                    },\n\n                    // This is the callback that would be executed when the tool is called:\n                    func(args map[string]interface{}) *mcp.CallToolResult {\n                        files, err := os.ReadDir(\".\")\n                        if err != nil {\n                            return &amp;mcp.CallToolResult{\n                                IsError: Ptr(true),\n                                Meta:    map[string]interface{}{},\n                                Content: []interface{}{\n                                    mcp.TextContent{\n                                        Type: \"text\",\n                                        Text: fmt.Sprintf(\"failed to read dir: %v\", err),\n                                    },\n                                },\n                            }\n                        }\n                        var contents []interface{} = make([]interface{}, len(files))\n                        for i, f := range files {\n                            contents[i] = mcp.TextContent{\n                                Type: \"text\",\n                                Text: f.Name(),\n                            }\n                        }\n\n                        return &amp;mcp.CallToolResult{\n                            Meta:    map[string]interface{}{},\n                            Content: contents,\n                            IsError: Ptr(false),\n                        }\n                    },\n                )\n            },\n        )),\n\n        // ToolMux registers tools and provides them to the server for listing tools and calling them\n        fxctx.ProvideToolMux(),\n\n        // Start the server using stdio transport\n        fx.Invoke((func(\n            lc fx.Lifecycle,\n            toolMux fxctx.ToolMux,\n        ) {\n            transport := stdio.NewTransport()\n            lc.Append(fx.Hook{\n                OnStart: func(ctx context.Context) error {\n                    go func() {\n                        transport.Run(\n                            &amp;mcp.ServerCapabilities{\n                                Tools: &amp;mcp.ServerCapabilitiesTools{\n                                    ListChanged: Ptr(false),\n                                },\n                            },\n                            &amp;mcp.Implementation{\n                                Name:    \"my-mcp-server\",\n                                Version: \"0.0.1\",\n                            },\n                            server.ServerStartCallbackOption{\n                                Callback: func(s server.Server) {\n                                    // This makes sure that server is aware of the tools\n                                    // we have registered and both can list and call them\n                                    toolMux.RegisterHandlers(s)\n                                },\n                            },\n                        )\n                    }()\n                    return nil\n                },\n                OnStop: func(ctx context.Context) error {\n                    return transport.Shutdown(ctx)\n                },\n            })\n        })),\n\n        // Just configuring fx logging to only show errors\n        fx.Provide(func() *zap.Logger {\n            cfg := zap.NewDevelopmentConfig()\n            cfg.Level.SetLevel(zap.ErrorLevel)\n            logger, _ := cfg.Build()\n            return logger\n        }),\n        fx.Option(fx.WithLogger(\n            func(logger *zap.Logger) fxevent.Logger {\n                return &amp;fxevent.ZapLogger{Logger: logger}\n            },\n        )),\n    ).Run()\n\n}\n\nfunc Ptr[T any](v T) *T {\n    return &amp;v\n}\n</code></pre>"},{"location":"prompts/","title":"Prompts","text":"<p>Prompts enable servers to define reusable prompt templates and workflows that clients can easily surface to users and LLMs</p> <p>MCP prompts is a concept of MCP servers. Server should list prompts when requested with method <code>prompts/list</code> and retrieve when requested with method <code>prompts/get</code>.</p> <p>Foxy Contexts allows easy way to define a prompt and register it within fx DI container.</p>"},{"location":"prompts/#newprompt","title":"NewPrompt","text":"<p>In order to create new prompt you shall use <code>fxctx.NewPrompt</code> function. It accepts prompt name, description and function that would be called when prompt is called.</p> <pre><code>func NewGreatPrompt() fxctx.Prompt {\n    return fxctx.NewPrompt(\n        // This information about the prompt would be used when it is listed:\n        mcp.Prompt{\n            Name:        \"my-great-prompt\",\n            Description: Ptr(\"Doing something great\"),\n            Arguments: []mcp.PromptArgument{\n                {\n                    Description: Ptr(\"An argument for the prompt\"),\n                    Name:        \"arg-1\",\n                    Required:    Ptr(true),\n                },\n            },\n        },\n        // This is the callback that would be executed when the prompt/get is requested:\n        func(req *mcp.GetPromptRequest) (*mcp.GetPromptResult, error) {\n            description := \"Prompting to do something great\"\n            return &amp;mcp.GetPromptResult{\n                Description: &amp;description,\n                Messages: []mcp.PromptMessage{\n                    {\n                        Content: mcp.TextContent{\n                            Type: \"text\",\n                            Text: \"Would you like to do something great?\",\n                        },\n                        Role: mcp.RoleUser,\n                    },\n                },\n            }, nil\n        },\n    )\n}\n</code></pre>"},{"location":"prompts/#provide-prompt-to-fx","title":"Provide prompt to fx","text":"<p>Now in order to let MCP server know about this prompt you would need to provide it to fx when creating fx app like this:</p> <pre><code>fx.New(\n    // other registered stuff ...\n    fx.Provide(fxctx.AsPrompt(NewGreatPrompt)),\n    // and more ...\n)\n</code></pre> <p><code>fxctx.AsPrompt</code> is a helper function that wraps your prompt into fx DI container and adds a certain tags, that would be used later to find all prompts and register them in MCP server.</p>"},{"location":"prompts/#promptmux","title":"PromptMux","text":"<p>Discovery and registration of prompts would be done by PromptMux, which you can simply provide to fx all like this:</p> <pre><code>fx.New(\n    // other registered stuff ...\n    fxctx.ProvidePromptMux(),\n    // and more ...\n)\n</code></pre> <p>To sum up you would need to provide all your prompts and PromptMux to fx:</p> <pre><code>fx.New(\n    // other registered stuff ...\n    fx.Provide(fxctx.AsPrompt(NewGreatPrompt)),\n    fx.Provide(fxctx.AsPrompt(NewAnotherPrompt)),\n    fxctx.ProvidePromptMux(),\n    // and more ...\n)\n</code></pre>"},{"location":"prompts/#wrapping-it-all-together","title":"Wrapping it all together","text":"<p>Finally, when starting the server, you would need to register handlers for prompts in your server using <code>server.ServerStartCallbackOption</code>:</p> <pre><code>fx.New(\n    // other registered stuff ...\n    fx.Provide(fxctx.AsPrompt(NewGreatPrompt)),\n    fx.Provide(fxctx.AsPrompt(NewAnotherPrompt)),\n    fxctx.ProvidePromptMux(), // this makes sure that PromptMux can get all our prompts and is provided itself\n    // and more ...\n\n    // Start the server using stdio transport\n    fx.Invoke((func(\n        lc fx.Lifecycle,\n        promptMux fxctx.PromptMux,\n    ) {\n        transport := stdio.NewTransport()\n        lc.Append(fx.Hook{\n            OnStart: func(ctx context.Context) error {\n                go func() {\n                    transport.Run(\n                        &amp;mcp.ServerCapabilities{\n                            Prompts: &amp;mcp.ServerCapabilitiesPrompts{\n                                ListChanged: Ptr(false),\n                            },\n                        },\n                        &amp;mcp.Implementation{\n                            Name:    \"my-mcp-great-server\",\n                            Version: \"0.0.1\",\n                        },\n                        server.ServerStartCallbackOption{\n                            Callback: func(s server.Server) {\n                                // This makes sure that server is aware of the prompts\n                                // we have registered and both can list and get them\n                                promptMux.RegisterHandlers(s)\n                            },\n                        },\n                    )\n                }()\n                return nil\n            },\n            OnStop: func(ctx context.Context) error {\n                return transport.Shutdown(ctx)\n            },\n        })\n    })),\n)\n</code></pre>"},{"location":"prompts/#examples","title":"Examples","text":"<p>Check out complete example of MCP Server with prompt:</p> <ul> <li>list_k8s_namespaces_prompt - provides a prompt listing k8s namespaces</li> </ul>"},{"location":"resources/","title":"Resources","text":"<p>Resources are a core primitive in the Model Context Protocol (MCP) that allow servers to expose data and content that can be read by clients and used as context for LLM interactions.</p> <p>MCP resources is a concept of MCP servers. Server should list resources when requested with method <code>resources/list</code> and retrieve when requested with method <code>resources/read</code>.</p> <p>Servers also can provide dynamic resources using templates by listing them via <code>resources/templates/list</code>, however this feature is not yet supported in Foxy Contexts.</p> <p>In Foxy Contexts there are two ways to include resources in your server:</p> <ul> <li>using <code>fxctx.NewResource</code> and <code>fxctx.AsResource</code> to define and provide resources</li> <li>using <code>fxctx.NewResourceProvider</code> and <code>fxctx.AsResourceProvider</code> to define and provide resource providers</li> </ul> <p>Approach with resource provider is more flexible and allows to provide resources dynamically, however all such resources would be still included in response for <code>resources/list</code>, in contrasts to concept of templates (which are not yet supported).</p>"},{"location":"resources/#newresource","title":"NewResource","text":"<p>In order to create new static resource you shall use <code>fxctx.NewResource</code> function.</p> <pre><code>func NewHelloWorldResource() fxctx.Resource {\n    return fxctx.NewResource(\n        mcp.Resource{\n            Name:        \"hello-world\",\n            Uri:         \"hello-world://hello-world\",\n            MimeType:    Ptr(\"application/json\"),\n            Description: Ptr(\"Hello World Resource\"),\n            Annotations: &amp;mcp.ResourceAnnotations{\n                Audience: []mcp.Role{\n                    mcp.RoleAssistant, mcp.RoleUser,\n                },\n            },\n        },\n        func(uri string) (*mcp.ReadResourceResult, error) {\n            return &amp;mcp.ReadResourceResult{\n                Contents: []interface{}{\n                    mcp.TextResourceContents{\n                        MimeType: Ptr(\"application/json\"),\n                        Text:     `{\"hello\": \"world\"}`,\n                        Uri:      uri,\n                    },\n                },\n            }, nil\n        },\n    )\n},\n</code></pre>"},{"location":"resources/#provide-resource-to-fx","title":"Provide resource to fx","text":"<p>Now in order to let MCP server know about this resource you would need to provide it to fx when creating fx app like this:</p> <pre><code>fx.New(\n    // other registered stuff ...\n    fx.Provide(fxctx.AsResource(NewHelloWorldResource)),\n    // and more ...\n)\n</code></pre> <p><code>fxctx.AsResource</code> is a helper function that wraps your resource into fx DI container and adds a certain tags, that would be used later to find all resources and register them in MCP server.</p> <p>Head further to ResourceMux to see how to register such resource in MCP server, or see next section to learn how to provide dynamic resources.</p>"},{"location":"resources/#newresourceprovider","title":"NewResourceProvider","text":"<p>In order to create new resource provider that would be returning resources dynamically, you shall use <code>fxctx.NewResourceProvider</code> function. It would then take two functions - one in order to list resources and another to read them.</p> <pre><code>func NewGreatResourceProvider() fxctx.ResourceProvider {\n    return fxctx.NewResourceProvider(\n        // This is the callback that would be executed when the resources/list is requested:\n        func() ([]mcp.Resource, error) {\n            return []mcp.Resource{\n                {\n                    Name: \"my-great-resource-one\",\n                    Description: Ptr(\"Does something great\"),\n                    Uri: \"/resources/great/one\",\n                },\n            }, nil\n        },\n        //  This function reads the resource for a given uri to run when resources/read is requested:\n        func(uri string) (*mcp.ReadResourceResult, error) {\n\n            // you would probably be doing something more complicated here\n            // like reading from a database or calling an external service\n            // based on what you have parsed from the uri\n            if uri == \"/resources/great/one\" {\n                return &amp;mcp.ReadResourceResult{\n                    Contents: []interface{}{\n                        mcp.TextResourceContents{\n                            MimeType: Ptr(\"application/json\"),\n                            Text:     string(`{\"great\": \"resource\"}`),\n                            Uri:      uri,\n                        }\n                    },\n                }, nil\n            }\n\n            // this error would be wrapped in JSON-RPC error response\n            return nil, fmt.Errorf(\"resource not found\")\n        },\n    )\n}\n</code></pre>"},{"location":"resources/#provide-resource-provider-to-fx","title":"Provide resource provider to fx","text":"<p>Now in order to let MCP server know about this resource provider you would need to provide it to fx when creating fx app like this:</p> <pre><code>fx.New(\n    // other registered stuff ...\n    fx.Provide(fxctx.AsResourceProvider(NewGreatResourceProvider)),\n    // and more ...\n)\n</code></pre> <p><code>fxctx.AsResourceProvider</code> is a helper function that wraps your resource provider into fx DI container and adds a certain tags, that would be used later to find all resource providers and register them in MCP server.</p>"},{"location":"resources/#resourcemux","title":"ResourceMux","text":"<p>Discovery and registration of resources would be done by ResourceMux, which you can simply provide to fx all like this:</p> <pre><code>fx.New(\n    // other registered stuff ...\n    fxctx.ProvideResourceMux(),\n    // and more ...\n)\n</code></pre> <p>To sum up you would need to provide all your resource providers and ResourceMux to fx:</p> <pre><code>fx.New(\n    // other registered stuff ...\n    fx.Provide(fxctx.AsResourceProvider(NewGreatResourceProvider)), // dynamic resources are provided by resource providers\n    fx.Provide(fxctx.AsResourceProvider(NewAnotherResourceProvider)), // you can provide multiple resource providers\n    fx.Provide(fxctx.AsResource(NewHelloWorldResource)), // static resources are provided directly\n    fxctx.ProvideResourceMux(),\n    // and more ...\n)\n</code></pre>"},{"location":"resources/#wrapping-it-all-together","title":"Wrapping it all together","text":"<p>Finally, when starting the server, you would need to register handlers for resources in your server using <code>server.ServerStartCallbackOption</code>:</p> <pre><code>fx.New(\n    // other registered stuff ...\n    fx.Provide(fxctx.AsResourceProvider(NewGreatResourceProvider)),\n    fx.Provide(fxctx.AsResourceProvider(NewAnotherResourceProvider)),\n    fx.Provide(fxctx.AsResource(NewHelloWorldResource)),\n    fxctx.ProvideResourceMux(), // this makes sure that ResourceMux can get all our resource providers and is provided itself\n\n    // Start the server using stdio transport\n    fx.Invoke((func(\n        lc fx.Lifecycle,\n        resourceMux fxctx.ResourceMux,\n    ) {\n        transport := stdio.NewTransport()\n        lc.Append(fx.Hook{\n            OnStart: func(ctx context.Context) error {\n                go func() {\n                    transport.Run(\n                        &amp;mcp.ServerCapabilities{\n                            Resources: &amp;mcp.ServerCapabilitiesResources{\n                                ListChanged: Ptr(false),\n                                Subscribe:   Ptr(false),\n                            },\n                        },\n                        &amp;mcp.Implementation{\n                            Name:    \"my-mcp-great-server\",\n                            Version: \"0.0.1\",\n                        },\n                        server.ServerStartCallbackOption{\n                            Callback: func(s server.Server) {\n                                // This makes sure that server is aware of the tools\n                                // we have registered and both can list and call them\n                                resourceMux.RegisterHandlers(s)\n                            },\n                        },\n                    )\n                }()\n                return nil\n            },\n            OnStop: func(ctx context.Context) error {\n                return transport.Shutdown(ctx)\n            },\n        })\n    })),\n)\n</code></pre>"},{"location":"resources/#examples","title":"Examples","text":"<p>Check out complete examples of MCP Servers with resources:</p> <ul> <li>k8s_contexts_resources - provides k8s contexts as resources</li> <li>hello_world_resource - provides one static very simple resource</li> <li>[git_repository_resource]https://github.com/strowk/foxy-contexts/tree/main/examples/hello_world_resource) - provides one static resource with information about git repository</li> </ul>"},{"location":"testing/","title":"Testing","text":""},{"location":"testing/#integration-testing-with-foxytest-using-mcp-story-format","title":"Integration Testing with foxytest using MCP Story format","text":"<p>In order to test your server, package <code>foxytest</code> is provided that allows you to easily start your server and test it using pre-defined JSON-RPC 2.0 messages.</p> <p><code>foxytest</code> currently only supports stdio transport.</p> <p>Here is an example how to setup integration tests:</p> <pre><code>import (\n    \"testing\"\n\n    \"github.com/strowk/foxy-contexts/pkg/foxytest\"\n)\n\nfunc TestWithFoxytest(t *testing.T) {\n    ts, err := foxytest.Read(\"testdata\")\n    if err != nil {\n        t.Fatal(err)\n    }\n    ts.WithExecutable(\"go\", []string{\"run\", \"main.go\"})\n    ts.WithLogging() // this adds logging to the test runner, you could see it if you run tests with -v flag\n    cntrl := foxytest.NewTestRunner(t)\n    ts.Run(cntrl)\n    ts.AssertNoErrors(cntrl)\n}\n</code></pre> <p>In folder <code>testdata</code>, you should have files with names ending on <code>_test.yaml</code>. These files should contain MCP Stories that would describe the test scenario. For example:</p> <pre><code>case: Empty tools list\nin_list_tools: {\"jsonrpc\":\"2.0\",\"method\":\"tools/list\",\"id\":1}\nout_no_tools: {\"jsonrpc\":\"2.0\",\"result\":{\"tools\":[]},\"id\":1}\n</code></pre> <p>This says that when client sends <code>tools/list</code> request, server should respond with empty list of tools.</p> <p>Tests could be single or multi-document YAML files. Each document should be a valid MCP Story, that means it should have <code>case</code> property with name of the test case and any number of properties prefixed with <code>in</code> and <code>out</code>, which would represent JSON-RPC 2.0 messages sent from client to server (<code>in</code>) and from server to client (<code>out</code>).</p> <p>When you run the test by executing <code>go test</code>, the test runner will start your server (by running <code>go run main.go</code> in this case), connect to stdio transport and send the message under <code>in</code> property. </p> <p>It will then wait for the response from server and compare it with the message under <code>out</code> property. If message is matching JSON structure, it will pass the test, otherwise it will fail and would print the diff between expected and actual JSON's.</p> <p>If you need more information from test run, and have configured logging with <code>ts.WithLogging()</code> you can then use <code>verbose</code> flag when running the test: <code>go test -v</code>, you will then see the output like this:</p> <pre><code>=== RUN   TestWithFoxytest\n    testsuite.go:55: setting up test suite\n    testsuite.go:59: running command: go run main.go\n    testsuite.go:59: running 1 tests\n    testsuite.go:55: waiting for command to finish\n    testsuite.go:59: expecting output: {\"id\":1,\"jsonrpc\":\"2.0\",\"result\":{\"tools\":[]}}\n    testsuite.go:59: sending input: {\"id\":1,\"jsonrpc\":\"2.0\",\"method\":\"tools/list\"}\n    testsuite.go:59: output matches: {\"jsonrpc\":\"2.0\",\"result\":{\"tools\":[]},\"id\":1}\n    testsuite.go:55: tests done\n    testsuite.go:55: running after all\n    testsuite.go:55: stop executable\n    testsuite.go:55: finished reading output\n    testsuite.go:55: executable stopped\n--- PASS: TestWithFoxytest (1.39s)\n</code></pre> <p>See following examples with tests: - examples/git_repository_resource/main_test.go - examples/hello_world_resource/main_test.go - examples/k8s_contexts_resources/main_test.go - examples/list_current_dir_files_tool/main_test.go</p>"},{"location":"tools/","title":"Tools","text":"<p>Through tools, LLMs can interact with external systems, perform computations, and take actions in the real world.</p> <p>MCP tools is a concept of MCP servers. Server should list tools when requested with method <code>tools/list</code> and call when requested with method <code>tools/call</code>.</p> <p>Foxy Contexts allows easy way to define a tool and register it within fx DI container.</p>"},{"location":"tools/#newtool","title":"NewTool","text":"<p>In order to create new tool you shall use <code>fxctx.NewTool</code> function. It accepts tool name, description and function that would be called when tool is called.</p> <pre><code>func NewGreatTool() fxctx.Tool {\n    return fxctx.NewTool(\n        // This information about the tool would be used when it is listed:\n        &amp;mcp.Tool{\n            Name: \"my-great-tool\",\n            Description: Ptr(\"Lists files in the current directory\"),\n            InputSchema: mcp.ToolInputSchema{ // here we tell client what we expect as input\n                Type:       \"object\",\n                Properties: map[string]map[string]interface{}{},\n                Required:   []string{},\n            },\n        }\n\n        // This is the callback that would be executed when the tool is called:\n        func(args map[string]interface{}) *mcp.CallToolResult {\n            // here we can do anything we want\n            return &amp;mcp.CallToolResult{\n                Content: []interface{}{\n                    mcp.TextContent{\n                        Type: \"text\",\n                        Text: fmt.Sprintf(\"Hello, World!\"),\n                    },\n                },\n            }\n        },\n    )\n}\n</code></pre>"},{"location":"tools/#provide-tool-to-fx","title":"Provide tool to fx","text":"<p>Now in order to let MCP server know about this tool you would need to provide it to fx when creating fx app like this:</p> <pre><code>fx.New(\n    // other registered stuff ...\n    fx.Provide(fxctx.AsTool(NewGreatTool)),\n    // and more ...\n)\n</code></pre> <p><code>fxctx.AsTool</code> is a helper function that wraps your tool into fx DI container and adds a certain tags, that would be used later to find all tools and register them in MCP server.</p>"},{"location":"tools/#toolmux","title":"ToolMux","text":"<p>Discovery and registration of tools would be done by ToolsMux, which you can simply provide to fx all like this:</p> <pre><code>fx.New(\n    // other registered stuff ...\n    fxctx.ProvideToolMux(),\n    // and more ...\n)\n</code></pre> <p>To sum up you would need to provide all your tools and ToolMux to fx:</p> <pre><code>fx.New(\n    // other registered stuff ...\n    fx.Provide(fxctx.AsTool(NewGreatTool)),\n    fx.Provide(fxctx.AsTool(NewAnotherTool)),\n    fxctx.ProvideToolMux(),\n    // and more ...\n)\n</code></pre>"},{"location":"tools/#wrapping-it-all-together","title":"Wrapping it all together","text":"<p>Finally, when starting the server, you would need to register handlers for tools in your server using <code>server.ServerStartCallbackOption</code>:</p> <pre><code>fx.New(\n    // other registered stuff ...\n    fx.Provide(fxctx.AsTool(NewGreatTool)),\n    fx.Provide(fxctx.AsTool(NewAnotherTool)),\n    fxctx.ProvideToolMux(), // this makes sure that ToolMux can get all our tools and is provided itself\n    // and more ...\n    fx.Invoke((func(\n        lc fx.Lifecycle,\n        toolMux fxctx.ToolMux, // and here we take ToolMux from fx so we can register handlers for tools\n    ) {\n        transport := stdio.NewTransport()\n        lc.Append(fx.Hook{\n            OnStart: func(ctx context.Context) error {\n                go func() {\n                    transport.Run(\n                        &amp;mcp.ServerCapabilities{\n                            Tools: &amp;mcp.ServerCapabilitiesTools{\n                                ListChanged: Ptr(false),\n                            },\n                        },\n                        &amp;mcp.Implementation{\n                            Name:    \"my-great-server\",\n                            Version: \"0.0.1\",\n                        },\n                        server.ServerStartCallbackOption{\n                            Callback: func(s server.Server) {\n                                // This makes sure that server is aware of the tools\n                                // we have registered and both can list and call them\n                                // serving for \"tools/list\" and \"tools/call\" requests\n                                toolMux.RegisterHandlers(s)\n                            },\n                        },\n                    )\n                }()\n                return nil\n            },\n            OnStop: func(ctx context.Context) error {\n                return transport.Shutdown(ctx)\n            },\n        })\n    })),\n)\n</code></pre>"},{"location":"tools/#examples","title":"Examples","text":"<p>Check out complete examples of MCP Servers with tools:</p> <ul> <li>list_current_dir_files_tool</li> <li>list_k8s_contexts_tool</li> </ul>"},{"location":"links/","title":"Links","text":""}]}