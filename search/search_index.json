{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"Overview","text":""},{"location":"#foxy-contexts-build-mcp-servers-declaratively-in-golang","title":"Foxy Contexts - Build MCP Servers Declaratively in Golang","text":"<p>Foxy contexts is a Golang library for building context servers supporting Model Context Protocol.</p> <p>This library only supports server side of the protocol. Using it you can build context servers using declarative approach, by defining tools, resources and prompts and then registering them with your FoxyApp, which is using uber's fx under the hood and you can inject into its container as well.</p> <p>With this approach you can easily colocate call/read/get logic and definitions of your tools/resources/prompts in a way that every tool/resource/prompt is placed in a separate place, but related code is colocated.</p> <p>Here is list of features that are already implemented:</p> <ul> <li>[x] Base (lifecycle/ping)</li> <li>[x] Stdio Transport</li> <li>[x] SSE Transport</li> <li>[x] Tools</li> <li>[x] Package toolinput helps define tools input schema and validate arriving input</li> <li>[x] Resources - static</li> <li>[x] Resources - dynamic via Resource Providers</li> <li>[x] Prompts</li> <li>[x] Prompts Completion</li> <li>[x] Functional Testing package foxytest</li> <li>[x] Simple building of your MCP server with the power of Dependency Injection</li> </ul> <p>And these are planned:</p> <ul> <li>[ ] Progress (planned)</li> <li>[ ] Resources - dynamic via Resource Templates (planned)</li> <li>[ ] Resource Templates completion (planned)</li> <li>[ ] Resource subscriptions</li> <li>[ ] Logging via MCP (planned)</li> <li>[ ] Sampling (planned)</li> <li>[ ] Roots (planned)</li> <li>[ ] Pagination (planned)</li> <li>[ ] Notifications list_changed (planned)</li> </ul> <p>Check docs and examples to know more.</p>"},{"location":"#tool-example","title":"Tool Example","text":"<p>For example try following</p> <p><pre><code>git clone https://github.com/strowk/foxy-contexts\ncd foxy-contexts/examples/list_current_dir_files_tool\nnpx @modelcontextprotocol/inspector go run main.go\n</code></pre> , then once inspector is started in browser open http://localhost:5173 and try to use list-current-dir-files.</p> <p>Here's the code of that example from examples/list_current_dir_files_tool/main.go (in real world application you would probably want to split it into multiple files):</p> <pre><code>package main\n\nimport (\n    \"fmt\"\n    \"os\"\n\n    \"github.com/strowk/foxy-contexts/pkg/app\"\n    \"github.com/strowk/foxy-contexts/pkg/fxctx\"\n    \"github.com/strowk/foxy-contexts/pkg/mcp\"\n    \"github.com/strowk/foxy-contexts/pkg/stdio\"\n    \"go.uber.org/fx\"\n    \"go.uber.org/fx/fxevent\"\n    \"go.uber.org/zap\"\n)\n\n// This example defines list-current-dir-files tool for MCP server, that prints files in the current directory\n// , run it with:\n// npx @modelcontextprotocol/inspector go run main.go\n// , then in browser open http://localhost:5173\n// , then click Connect\n// , then click List Tools\n// , then click list-current-dir-files\n\n// NewListCurrentDirFilesTool defines a tool that lists files in the current directory\nfunc NewListCurrentDirFilesTool() fxctx.Tool {\n    return fxctx.NewTool(\n        // This information about the tool would be used when it is listed:\n        &amp;mcp.Tool{\n            Name:        \"list-current-dir-files\",\n            Description: Ptr(\"Lists files in the current directory\"),\n            InputSchema: mcp.ToolInputSchema{\n                Type:       \"object\",\n                Properties: map[string]map[string]interface{}{},\n                Required:   []string{},\n            },\n        },\n\n        // This is the callback that would be executed when the tool is called:\n        func(args map[string]interface{}) *mcp.CallToolResult {\n            files, err := os.ReadDir(\".\")\n            if err != nil {\n                return &amp;mcp.CallToolResult{\n                    IsError: Ptr(true),\n                    Meta:    map[string]interface{}{},\n                    Content: []interface{}{\n                        mcp.TextContent{\n                            Type: \"text\",\n                            Text: fmt.Sprintf(\"failed to read dir: %v\", err),\n                        },\n                    },\n                }\n            }\n            var contents []interface{} = make([]interface{}, len(files))\n            for i, f := range files {\n                contents[i] = mcp.TextContent{\n                    Type: \"text\",\n                    Text: f.Name(),\n                }\n            }\n\n            return &amp;mcp.CallToolResult{\n                Meta:    map[string]interface{}{},\n                Content: contents,\n                IsError: Ptr(false),\n            }\n        },\n    )\n}\n\nfunc main() {\n    app.\n        NewFoxyApp().\n        // adding the tool to the app\n        WithTool(NewListCurrentDirFilesTool).\n        // setting up server\n        WithName(\"list-current-dir-files\").\n        WithVersion(\"0.0.1\").\n        WithTransport(stdio.NewTransport()).\n        // Configuring fx logging to only show errors\n        WithFxOptions(fx.Provide(func() *zap.Logger {\n                cfg := zap.NewDevelopmentConfig()\n                cfg.Level.SetLevel(zap.ErrorLevel)\n                logger, _ := cfg.Build()\n                return logger\n            }),\n            fx.Option(fx.WithLogger(\n                func(logger *zap.Logger) fxevent.Logger {\n                    return &amp;fxevent.ZapLogger{Logger: logger}\n                },\n            )),\n        ).\n        Run()\n}\n\nfunc Ptr[T any](v T) *T {\n    return &amp;v\n}\n</code></pre>"},{"location":"prompts/","title":"Prompts","text":"<p>Prompts enable servers to define reusable prompt templates and workflows that clients can easily surface to users and LLMs</p> <p>MCP prompts is a concept of MCP servers. Server should list prompts when requested with method <code>prompts/list</code> and retrieve when requested with method <code>prompts/get</code>.</p> <p>Foxy Contexts allows easy way to define a prompt and register it within fx DI container.</p>"},{"location":"prompts/#newprompt","title":"NewPrompt","text":"<p>In order to create new prompt you shall use <code>fxctx.NewPrompt</code> function. It accepts prompt name, description and function that would be called when prompt is called.</p> <pre><code>func NewGreatPrompt() fxctx.Prompt {\n    return fxctx.NewPrompt(\n        // This information about the prompt would be used when it is listed:\n        mcp.Prompt{\n            Name:        \"my-great-prompt\",\n            Description: Ptr(\"Doing something great\"),\n            Arguments: []mcp.PromptArgument{\n                {\n                    Description: Ptr(\"An argument for the prompt\"),\n                    Name:        \"arg-1\",\n                    Required:    Ptr(true),\n                },\n            },\n        },\n        // This is the callback that would be executed when the prompt/get is requested:\n        func(req *mcp.GetPromptRequest) (*mcp.GetPromptResult, error) {\n            description := \"Prompting to do something great\"\n            return &amp;mcp.GetPromptResult{\n                Description: &amp;description,\n                Messages: []mcp.PromptMessage{\n                    {\n                        Content: mcp.TextContent{\n                            Type: \"text\",\n                            Text: \"Would you like to do something great?\",\n                        },\n                        Role: mcp.RoleUser,\n                    },\n                },\n            }, nil\n        },\n    )\n}\n</code></pre>"},{"location":"prompts/#register-prompt-and-start-server","title":"Register prompt and start server","text":"<pre><code>func main() {\n    app.\n        NewFoxyApp().\n        // adding the tool to the app\n        WithPrompt(NewGreatPrompt).\n        // setting up server\n        WithName(\"great-tool-server\").\n        WithVersion(\"0.0.1\").\n        WithTransport(stdio.NewTransport()).\n        // Configuring fx logging to only show errors\n        WithFxOptions(\n            fx.Provide(func() *zap.Logger {\n                cfg := zap.NewDevelopmentConfig()\n                cfg.Level.SetLevel(zap.ErrorLevel)\n                logger, _ := cfg.Build()\n                return logger\n            }),\n            fx.Option(fx.WithLogger(\n                func(logger *zap.Logger) fxevent.Logger {\n                    return &amp;fxevent.ZapLogger{Logger: logger}\n                },\n            )),\n        ).Run()\n}\n</code></pre>"},{"location":"prompts/#examples","title":"Examples","text":"<p>Check out complete example of MCP Server with prompt:</p> <ul> <li>simple_prompt - provides a very basic prompt</li> <li>list_k8s_namespaces_prompt - provides a prompt listing k8s namespaces</li> </ul>"},{"location":"resources/","title":"Resources","text":"<p>Resources are a core primitive in the Model Context Protocol (MCP) that allow servers to expose data and content that can be read by clients and used as context for LLM interactions.</p> <p>MCP resources is a concept of MCP servers. Server should list resources when requested with method <code>resources/list</code> and retrieve when requested with method <code>resources/read</code>.</p> <p>Servers also can provide dynamic resources using templates by listing them via <code>resources/templates/list</code>, however this feature is not yet supported in Foxy Contexts.</p> <p>In Foxy Contexts there are two ways to include resources in your server:</p> <ul> <li>using <code>fxctx.NewResource</code> to define static resources</li> <li>using <code>fxctx.NewResourceProvider</code> to define resource providers</li> </ul> <p>Approach with resource provider is more flexible and allows to provide resources dynamically, however all such resources would be still included in response for <code>resources/list</code>, in contrasts to concept of templates (which are not yet supported).</p>"},{"location":"resources/#newresource","title":"NewResource","text":"<p>In order to create new static resource you shall use <code>fxctx.NewResource</code> function.</p> <pre><code>func NewGreatResource() fxctx.Resource {\n    return fxctx.NewResource(\n        mcp.Resource{\n            Name:        \"hello-world\",\n            Uri:         \"hello-world://hello-world\",\n            MimeType:    Ptr(\"application/json\"),\n            Description: Ptr(\"Hello World Resource\"),\n            Annotations: &amp;mcp.ResourceAnnotations{\n                Audience: []mcp.Role{\n                    mcp.RoleAssistant, mcp.RoleUser,\n                },\n            },\n        },\n        func(uri string) (*mcp.ReadResourceResult, error) {\n            return &amp;mcp.ReadResourceResult{\n                Contents: []interface{}{\n                    mcp.TextResourceContents{\n                        MimeType: Ptr(\"application/json\"),\n                        Text:     `{\"hello\": \"world\"}`,\n                        Uri:      uri,\n                    },\n                },\n            }, nil\n        },\n    )\n}\n</code></pre>"},{"location":"resources/#register-resources-and-start-server","title":"Register resources and start server","text":"<pre><code>func main() {\n    err := app.\n        NewFoxyApp().\n        // adding the resource to the app\n        WithResource(NewGreatResource).\n        // setting up server\n        WithName(\"my-mcp-server\").\n        WithVersion(\"0.0.1\").\n        WithTransport(stdio.NewTransport()).\n        // Configuring fx logging to only show errors\n        WithFxOptions(\n            fx.Provide(func() *zap.Logger {\n                cfg := zap.NewDevelopmentConfig()\n                cfg.Level.SetLevel(zap.ErrorLevel)\n                logger, _ := cfg.Build()\n                return logger\n            }),\n            fx.Option(fx.WithLogger(\n                func(logger *zap.Logger) fxevent.Logger {\n                    return &amp;fxevent.ZapLogger{Logger: logger}\n                },\n            )),\n        ).Run()\n\n    if err != nil {\n        log.Fatal(err)\n    }\n}\n</code></pre>"},{"location":"resources/#newresourceprovider","title":"NewResourceProvider","text":"<p>In order to create new resource provider that would be returning resources dynamically, you shall use <code>fxctx.NewResourceProvider</code> function. It would then take two functions - one in order to list resources and another to read them.</p> <pre><code>func NewGreatResourceProvider() fxctx.ResourceProvider {\n    return fxctx.NewResourceProvider(\n        // This is the callback that would be executed when the resources/list is requested:\n        func() ([]mcp.Resource, error) {\n            return []mcp.Resource{\n                {\n                    Name: \"my-great-resource-one\",\n                    Description: Ptr(\"Does something great\"),\n                    Uri: \"/resources/great/one\",\n                },\n            }, nil\n        },\n        //  This function reads the resource for a given uri to run when resources/read is requested:\n        func(uri string) (*mcp.ReadResourceResult, error) {\n\n            // you would probably be doing something more complicated here\n            // like reading from a database or calling an external service\n            // based on what you have parsed from the uri\n            if uri == \"/resources/great/one\" {\n                return &amp;mcp.ReadResourceResult{\n                    Contents: []interface{}{\n                        mcp.TextResourceContents{\n                            MimeType: Ptr(\"application/json\"),\n                            Text:     string(`{\"great\": \"resource\"}`),\n                            Uri:      uri,\n                        }\n                    },\n                }, nil\n            }\n\n            // this error would be wrapped in JSON-RPC error response\n            return nil, fmt.Errorf(\"resource not found\")\n        },\n    )\n}\n</code></pre>"},{"location":"resources/#examples","title":"Examples","text":"<p>Check out complete examples of MCP Servers with resources:</p> <ul> <li>k8s_contexts_resources - provides k8s contexts as resources</li> <li>hello_world_resource - provides one static very simple resource</li> <li>git_repository_resource - provides one static resource with information about git repository</li> </ul>"},{"location":"testing/","title":"Testing","text":""},{"location":"testing/#integration-testing-with-foxytest-using-mcp-cases-format","title":"Integration Testing with foxytest using MCP Cases format","text":"<p>In order to test your server, package <code>foxytest</code> is provided that allows you to easily start your server and test it using pre-defined JSON-RPC 2.0 messages.</p> <p><code>foxytest</code> currently only supports stdio transport.</p> <p>Here is an example how to setup integration tests:</p> <pre><code>import (\n    \"testing\"\n\n    \"github.com/strowk/foxy-contexts/pkg/foxytest\"\n)\n\nfunc TestWithFoxytest(t *testing.T) {\n    ts, err := foxytest.Read(\"testdata\")\n    if err != nil {\n        t.Fatal(err)\n    }\n    ts.WithExecutable(\"go\", []string{\"run\", \"main.go\"})\n    ts.WithLogging() // this adds logging to the test runner, you could see it if you run tests with -v flag\n    cntrl := foxytest.NewTestRunner(t)\n    ts.Run(cntrl)\n    ts.AssertNoErrors(cntrl)\n}\n</code></pre> <p>In folder <code>testdata</code>, you should have files with names ending on <code>_test.yaml</code>. These files should contain MCP Stories that would describe the test scenario. For example:</p> <pre><code>case: Empty tools list\nin_list_tools: {\"jsonrpc\":\"2.0\",\"method\":\"tools/list\",\"id\":1}\nout_no_tools: {\"jsonrpc\":\"2.0\",\"result\":{\"tools\":[]},\"id\":1}\n</code></pre> <p>This says that when client sends <code>tools/list</code> request, server should respond with empty list of tools.</p> <p>Tests could be single or multi-document YAML files. Each document should be in a valid MCP Cases format, that means it can have <code>case</code> property with name of the test case and any number of properties prefixed with <code>in</code> and <code>out</code>, which would represent JSON-RPC 2.0 messages sent from client to server (<code>in</code>) and from server to client (<code>out</code>).</p> <p>When you run the test by executing <code>go test</code>, the test runner will start your server (by running <code>go run main.go</code> in this case), connect to stdio transport and send the message under <code>in</code> property. </p> <p>It will then wait for the response from server and compare it with the message under <code>out</code> property. If message is matching JSON structure, it will pass the test, otherwise it will fail and would print the diff between expected and actual JSON's.</p> <p>If you need more information from test run, and have configured logging with <code>ts.WithLogging()</code> you can then use <code>verbose</code> flag when running the test: <code>go test -v</code>, you will then see the output like this:</p> <pre><code>=== RUN   TestWithFoxytest\n    testsuite.go:55: setting up test suite\n    testsuite.go:59: running command: go run main.go\n    testsuite.go:59: running 1 tests\n    testsuite.go:55: waiting for command to finish\n    testsuite.go:59: expecting output: {\"id\":1,\"jsonrpc\":\"2.0\",\"result\":{\"tools\":[]}}\n    testsuite.go:59: sending input: {\"id\":1,\"jsonrpc\":\"2.0\",\"method\":\"tools/list\"}\n    testsuite.go:59: output matches: {\"jsonrpc\":\"2.0\",\"result\":{\"tools\":[]},\"id\":1}\n    testsuite.go:55: tests done\n    testsuite.go:55: running after all\n    testsuite.go:55: stop executable\n    testsuite.go:55: finished reading output\n    testsuite.go:55: executable stopped\n--- PASS: TestWithFoxytest (1.39s)\n</code></pre> <p>See following examples with tests: - examples/git_repository_resource/main_test.go - examples/hello_world_resource/main_test.go - examples/k8s_contexts_resources/main_test.go - examples/list_current_dir_files_tool/main_test.go</p>"},{"location":"tools/","title":"Tools","text":"<p>Through tools, LLMs can interact with external systems, perform computations, and take actions in the real world.</p> <p>MCP tools is a concept of MCP servers. Server should list tools when requested with method <code>tools/list</code> and call when requested with method <code>tools/call</code>.</p> <p>Foxy Contexts allows easy way to define a tool and register it within fx DI container.</p>"},{"location":"tools/#newtool","title":"NewTool","text":"<p>In order to create new tool you shall use <code>fxctx.NewTool</code> function. It accepts tool name, description and function that would be called when tool is called.</p> <pre><code>func NewGreatTool() fxctx.Tool {\n    return fxctx.NewTool(\n        // This information about the tool would be used when it is listed:\n        &amp;mcp.Tool{\n            Name:        \"my-great-tool\",\n            Description: Ptr(\"The great tool\"),\n            InputSchema: mcp.ToolInputSchema{ // here we tell client what we expect as input\n                Type:       \"object\",\n                Properties: map[string]map[string]interface{}{},\n                Required:   []string{},\n            },\n        },\n\n        // This is the callback that would be executed when the tool is called:\n        func(args map[string]interface{}) *mcp.CallToolResult {\n            // here we can do anything we want\n            return &amp;mcp.CallToolResult{\n                Content: []interface{}{\n                    mcp.TextContent{\n                        Type: \"text\",\n                        Text: fmt.Sprintf(\"Sup\"),\n                    },\n                },\n            }\n        },\n    )\n}\n</code></pre>"},{"location":"tools/#register-tool-and-start-server","title":"Register tool and start server","text":"<pre><code>func main() {\n    app.\n        NewFoxyApp().\n        // adding the tool to the app\n        WithTool(NewGreatTool).\n        // setting up server\n        WithName(\"great-tool-server\").\n        WithVersion(\"0.0.1\").\n        WithTransport(stdio.NewTransport()).\n        // Configuring fx logging to only show errors\n        WithFxOptions(\n            fx.Provide(func() *zap.Logger {\n                cfg := zap.NewDevelopmentConfig()\n                cfg.Level.SetLevel(zap.ErrorLevel)\n                logger, _ := cfg.Build()\n                return logger\n            }),\n            fx.Option(fx.WithLogger(\n                func(logger *zap.Logger) fxevent.Logger {\n                    return &amp;fxevent.ZapLogger{Logger: logger}\n                },\n            )),\n        ).Run()\n}\n</code></pre>"},{"location":"tools/#examples","title":"Examples","text":"<p>Check out complete examples of MCP Servers with tools:</p> <ul> <li>list_current_dir_files_tool</li> <li>list_k8s_contexts_tool</li> </ul>"},{"location":"links/","title":"Links","text":""}]}