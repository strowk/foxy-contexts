{"/app_builder/":{"data":{"appbuilder#app.Builder":"","usage#Usage":"app.Builderapp.Builder is a builder around uber’s fx that combines fx DI capabilities with foxy-contexts MCP server implementation and gives simple interface to combine your MCP primitives into a single standalone application.\nUsage Simple example of wrapping one tool into an application, then running it with stdio transport:\nexamples/simple_great_tool/main.go\rfunc main() { app. NewBuilder(). // adding the tool to the app WithTool(NewGreatTool). // setting up server WithName(\"great-tool-server\"). WithVersion(\"0.0.1\"). WithTransport(stdio.NewTransport()). // Configuring fx logging to only show errors WithFxOptions( fx.Provide(func() *zap.Logger { cfg := zap.NewDevelopmentConfig() cfg.Level.SetLevel(zap.ErrorLevel) logger, _ := cfg.Build() return logger }), fx.Option(fx.WithLogger( func(logger *zap.Logger) fxevent.Logger { return \u0026fxevent.ZapLogger{Logger: logger} }, )), ).Run() } Providing additional server options Normally app.Builder preconfigure server for you, but you can provide additional server options to the application by using WithExtraServerOptions option.\nSay, for example this would make server to turn on logging to stderr:\nWithExtraServerOptions(server.LoggerOption{ Logger: foxyevent.NewSlogLogger(slog.New(slog.NewTextHandler(os.Stderr, \u0026slog.HandlerOptions{ Level: slog.LevelDebug, }))).WithLogLevel(slog.LevelInfo), }) "},"title":"app_builder"},"/dependencies/":{"data":{"dependencies#Dependencies":"","extracting-dependency#Extracting dependency":"DependenciesThe power of Foxy Contexts comes from being based on DI concept facilitated by fx library. This allows to easily extract common parts of your server into separate packages and reuse them in different tools, prompts and other parts of your server.\nYou can learn more about fx in official documentation, here there are just some common patterns that you might find useful.\nExtracting dependency When you have identified that there is some bit that you need to repeat across tools, and maybe also for performance reasons you want to extract it and share, you can start with creating a function that creates that shared part.\nFollowing is example for extracting k8s configuration:\nexamples/list_k8s_contexts_tool/k8s.go\r// NewK8sClientConfig creates a new k8s client config // , which we define separately in order to give it to // fx to later inject it into potentially several tools as a dependency func NewK8sClientConfig() clientcmd.ClientConfig { loadingRules := clientcmd.NewDefaultClientConfigLoadingRules() return clientcmd.NewNonInteractiveDeferredLoadingClientConfig(loadingRules, nil) } With this in place, you can then define how the dependency would be injected into the tool you are creating:\nexamples/list_k8s_contexts_tool/main.go\rfunc NewListK8sContextsTool(kubeConfig clientcmd.ClientConfig) fxctx.Tool { The final step would be to provide everything to your app.Builder:\nexamples/list_k8s_contexts_tool/main.go\rapp. NewBuilder(). WithFxOptions( fx.Provide(NewK8sClientConfig), ). WithTool(NewListK8sContextsTool). "},"title":"dependencies"},"/prompts/":{"data":{"examples#Examples":"Prompts Prompts enable servers to define reusable prompt templates and workflows that clients can easily surface to users and LLMs\nMCP prompts is a concept of MCP servers. Server should list prompts when requested with method prompts/list and retrieve when requested with method prompts/get.\nFoxy Contexts allows easy way to define a prompt and register it within fx DI container.\nNewPrompt In order to create new prompt you shall use fxctx.NewPrompt function. It accepts prompt name, description and function that would be called when prompt is called.\nexamples/simple_prompt/main.go\rfunc NewGreatPrompt() fxctx.Prompt { return fxctx.NewPrompt( // This information about the prompt would be used when it is listed: mcp.Prompt{ Name: \"my-great-prompt\", Description: Ptr(\"Doing something great\"), Arguments: []mcp.PromptArgument{ { Description: Ptr(\"An argument for the prompt\"), Name: \"arg-1\", Required: Ptr(true), }, }, }, // This is the callback that would be executed when the prompt/get is requested: func(_ context.Context, req *mcp.GetPromptRequest) (*mcp.GetPromptResult, error) { description := \"Prompting to do something great\" return \u0026mcp.GetPromptResult{ Description: \u0026description, Messages: []mcp.PromptMessage{ { Content: mcp.TextContent{ Type: \"text\", Text: \"Would you like to do something great?\", }, Role: mcp.RoleUser, }, }, }, nil }, ) } Register prompt and start server examples/simple_prompt/main.go\rfunc main() { app. NewBuilder(). // adding the tool to the app WithPrompt(NewGreatPrompt). // setting up server WithName(\"great-tool-server\"). WithVersion(\"0.0.1\"). WithTransport(stdio.NewTransport()). // Configuring fx logging to only show errors WithFxOptions( fx.Provide(func() *zap.Logger { cfg := zap.NewDevelopmentConfig() cfg.Level.SetLevel(zap.ErrorLevel) logger, _ := cfg.Build() return logger }), fx.Option(fx.WithLogger( func(logger *zap.Logger) fxevent.Logger { return \u0026fxevent.ZapLogger{Logger: logger} }, )), ).Run() } Examples Check out complete example of MCP Server with prompt:\nsimple_prompt - provides a very basic prompt list_k8s_namespaces_prompt - provides a prompt listing k8s namespaces ","newprompt#NewPrompt":"","prompts#Prompts":"","register-prompt-and-start-server#Register prompt and start server":""},"title":"prompts"},"/resources/":{"data":{"":"","examples#Examples":" Resources are a core primitive in the Model Context Protocol (MCP) that allow servers to expose data and content that can be read by clients and used as context for LLM interactions.\nMCP resources is a concept of MCP servers. Server should list resources when requested with method resources/list and retrieve when requested with method resources/read.\nServers also can provide dynamic resources using templates by listing them via resources/templates/list, however this feature is not yet supported in Foxy Contexts.\nIn Foxy Contexts there are two ways to include resources in your server:\nusing fxctx.NewResource to define static resources using fxctx.NewResourceProvider to define resource providers Approach with resource provider is more flexible and allows to provide resources dynamically, however all such resources would be still included in response for resources/list, in contrasts to concept of templates (which are not yet supported).\nNewResource In order to create new static resource you shall use fxctx.NewResource function.\nexamples/hello_world_resource/main.go\rfunc NewGreatResource() fxctx.Resource { return fxctx.NewResource( mcp.Resource{ Name: \"hello-world\", Uri: \"hello-world://hello-world\", MimeType: Ptr(\"application/json\"), Description: Ptr(\"Hello World Resource\"), Annotations: \u0026mcp.ResourceAnnotations{ Audience: []mcp.Role{ mcp.RoleAssistant, mcp.RoleUser, }, }, }, func(_ context.Context, uri string) (*mcp.ReadResourceResult, error) { return \u0026mcp.ReadResourceResult{ Contents: []interface{}{ mcp.TextResourceContents{ MimeType: Ptr(\"application/json\"), Text: `{\"hello\": \"world\"}`, Uri: uri, }, }, }, nil }, ) } Register resources and start server examples/hello_world_resource/main.go\rfunc main() { err := app. NewBuilder(). // adding the resource to the app WithResource(NewGreatResource). // setting up server WithName(\"my-mcp-server\"). WithVersion(\"0.0.1\"). WithTransport(stdio.NewTransport()). // Configuring fx logging to only show errors WithFxOptions( fx.Provide(func() *zap.Logger { cfg := zap.NewDevelopmentConfig() cfg.Level.SetLevel(zap.ErrorLevel) logger, _ := cfg.Build() return logger }), fx.Option(fx.WithLogger( func(logger *zap.Logger) fxevent.Logger { return \u0026fxevent.ZapLogger{Logger: logger} }, )), ).Run() if err != nil { log.Fatal(err) } } NewResourceProvider In order to create new resource provider that would be returning resources dynamically, you shall use fxctx.NewResourceProvider function. It would then take two functions - one in order to list resources and another to read them.\nexamples/resource_provider/main.go\rfunc NewGreatResourceProvider() fxctx.ResourceProvider { return fxctx.NewResourceProvider( // This is the callback that would be executed when the resources/list is requested: func(_ context.Context) ([]mcp.Resource, error) { return []mcp.Resource{ { Name: \"my-great-resource-one\", Description: Ptr(\"Does something great\"), Uri: \"/resources/great/one\", }, }, nil }, // This function reads the resource for a given uri to run when resources/read is requested: func(_ context.Context, uri string) (*mcp.ReadResourceResult, error) { // you would probably be doing something more complicated here // like reading from a database or calling an external service // based on what you have parsed from the uri if uri == \"/resources/great/one\" { return \u0026mcp.ReadResourceResult{ Contents: []interface{}{ mcp.TextResourceContents{ MimeType: Ptr(\"application/json\"), Text: string(`{\"great\": \"resource\"}`), Uri: uri, }, }, }, nil } // this error would be wrapped in JSON-RPC error response return nil, fmt.Errorf(\"resource not found\") }, ) } Examples Check out complete examples of MCP Servers with resources:\nk8s_contexts_resources - provides k8s contexts as resources hello_world_resource - provides one static very simple resource git_repository_resource - provides one static resource with information about git repository ","newresource#NewResource":"","newresourceprovider#NewResourceProvider":"","register-resources-and-start-server#Register resources and start server":""},"title":"Resources"},"/testing/":{"data":{"embedded-regex#Embedded regex":"","examples#Examples":"Testingfoxytest In order to test your server, package foxytest is provided that allows you to easily start your server and test it using pre-defined JSON-RPC 2.0 messages.\nfoxytest currently supports stdio and streamable HTTP transports.\nHere is an example how to setup integration tests:\nimport ( \"testing\" \"github.com/strowk/foxy-contexts/pkg/foxytest\" ) func TestWithFoxytest(t *testing.T) { ts, err := foxytest.Read(\"testdata\") if err != nil { t.Fatal(err) } ts.WithExecutable(\"go\", []string{\"run\", \"main.go\"}) ts.WithLogging() // this adds logging to the test runner, you could see it if you run tests with -v flag cntrl := foxytest.NewTestRunner(t) ts.Run(cntrl) ts.AssertNoErrors(cntrl) } In folder testdata, you should have files with names ending on _test.yaml. These files should contain MCP Stories that would describe the test scenario. For example:\ncase: Empty tools list in_list_tools: {\"jsonrpc\":\"2.0\",\"method\":\"tools/list\",\"id\":1} out_no_tools: {\"jsonrpc\":\"2.0\",\"result\":{\"tools\":[]},\"id\":1} This says that when client sends tools/list request, server should respond with empty list of tools.\nTests could be single or multi-document YAML files. Each document should be in a valid MCP Cases format, that means it can have case property with name of the test case and any number of properties prefixed with in and out, which would represent JSON-RPC 2.0 messages sent from client to server (in) and from server to client (out).\nWhen you run the test by executing go test, the test runner will start your server (by running go run main.go in this case), connect to stdio transport and send the message under in property.\nIt will then wait for the response from server and compare it with the message under out property. If message is matching JSON structure, it will pass the test, otherwise it will fail and would print the diff between expected and actual JSON’s.\nIf you need more information from test run, and have configured logging with ts.WithLogging() you can then use verbose flag when running the test: go test -v, you will then see the output like this:\n=== RUN TestWithFoxytest\rtestsuite.go:55: setting up test suite\rtestsuite.go:59: running command: go run main.go\rtestsuite.go:59: running 1 tests\rtestsuite.go:55: waiting for command to finish\rtestsuite.go:59: expecting output: {\"id\":1,\"jsonrpc\":\"2.0\",\"result\":{\"tools\":[]}}\rtestsuite.go:59: sending input: {\"id\":1,\"jsonrpc\":\"2.0\",\"method\":\"tools/list\"}\rtestsuite.go:59: output matches: {\"jsonrpc\":\"2.0\",\"result\":{\"tools\":[]},\"id\":1}\rtestsuite.go:55: tests done\rtestsuite.go:55: running after all\rtestsuite.go:55: stop executable\rtestsuite.go:55: finished reading output\rtestsuite.go:55: executable stopped\r--- PASS: TestWithFoxytest (1.39s) When failed, package attempts to pretty print the diff between expected and actual JSON’s, so you can quickly locate the issue.\nHere is an example of real world failing test:\ntestsuite.go:54:\r\"result\": {\r\"content\": {\r\"0\": {\r\"text\": {\r^ value does not match the embedded regex:\rexpected to match: \"{\"name\":\"k3d-mcp-k8s-test-server-0\",\"status\":\"Active\",\"age\":\"/[\\\\d][sm]/\",\"createdAt\":\"/[\\\\d]{4}/-/[\\\\d]{2}/-/[\\\\d]{2}/T/[\\\\d]{2}/:/[\\\\d]{2}/:/[\\\\d]{2}/Z\"}\",\rbut got: \"{\"name\":\"k3d-mcp-k8s-integration-test-server-0\",\"status\":\"Unknown\",\"age\":\"1m0s\"}\" Output is not a valid JSON, it just attempts to show the difference at the right point in structure.\nMatch with regex Sometimes when you have dynamic values in your responses, you might want to use regular expressions to match them. You can do this by using !!re tag in your expected output. For example:\ncase: List tools in_list_tools: {\"jsonrpc\":\"2.0\",\"method\":\"tools/list\",\"id\":1} out_list_tools: {\"jsonrpc\":\"2.0\",\"result\":{\"tools\":[ { \"name\": !!re \"list-[a-z]+\" } ]},\"id\":1} This example is somewhat oversimplified, in reality you would probably use !!re with timestamps, UUIDs or other dynamic values, rather than tool names. It does, however, demonstrate that strings with !!re tag would be treated as regular expressions and would be matched against actual values using regular expression matching instead of string equality.\nEmbedded regex Embedded regular expression is just a regular expression that is embedded in a string. It is used to match a part of the string. For example:\ncase: List tools in_list_tools: {\"jsonrpc\":\"2.0\",\"method\":\"tools/list\",\"id\":1} out_list_tools: {\"jsonrpc\":\"2.0\",\"result\":{\"tools\":[ { \"name\": !!ere \"list-/[a-z]+/-tool\" } ]},\"id\":1} Essentially !!ere allows you to treat most of the string as just regular string, but have a part (or parts) of it treated as regular expression. Everything inside slashes / would be treated as regular expression, here “list-” and “-tool” are regular strings, but [a-z]+ is a regular expression that would match any lowercase letters non-empty string, so it would match “list-abc-tool”, “list-xyz-tool” and so on.\nThis approach allows you not to think how to escape regular expression syntax in the rest of your string and only match bits that you need to be dynamic.\nEscaping forward slashes You do, however need to escape slashes / in places of your string where you want to use them, but not designate regular expression, for example: \"url\": !! \"https:\\\\/\\\\/foxy-contexts.str4.io\\\\//[a-z]+/\" would match \"url\": \"https://foxy-contexts.str4.io/abc\". In here \\\\/ is used to become / and [a-z]+ is used to match any lowercase letters non-empty string. The reason why there are two backslashes \\\\ is because in YAML strings backslash is an escape character, so to have a single backslash in the string you need to escape it with another backslash.\nExamples See following examples with tests:\nexamples/git_repository_resource/main_test.go examples/hello_world_resource/main_test.go examples/k8s_contexts_resources/main_test.go examples/list_current_dir_files_tool/main_test.go ","foxytest#foxytest":"","match-with-regex#Match with regex":"","testing#Testing":""},"title":"testing"},"/tools/":{"data":{"":"","examples#Examples":" Through tools, LLMs can interact with external systems, perform computations, and take actions in the real world.\nMCP tools is a concept of MCP servers. Server should list tools when requested with method tools/list and call when requested with method tools/call.\nFoxy Contexts allows easy way to define a tool and register it within fx DI container.\nNewTool In order to create new tool you shall use fxctx.NewTool function. It accepts tool name, description and function that would be called when tool is called.\nexamples/simple_great_tool/main.go\rfunc NewGreatTool() fxctx.Tool { return fxctx.NewTool( // This information about the tool would be used when it is listed: \u0026mcp.Tool{ Name: \"my-great-tool\", Description: Ptr(\"The great tool\"), InputSchema: mcp.ToolInputSchema{ // here we tell client what we expect as input Type: \"object\", Properties: map[string]map[string]interface{}{}, Required: []string{}, }, }, // This is the callback that would be executed when the tool is called: func(_ context.Context, args map[string]interface{}) *mcp.CallToolResult { // here we can do anything we want return \u0026mcp.CallToolResult{ Content: []interface{}{ mcp.TextContent{ Type: \"text\", Text: fmt.Sprintf(\"Sup\"), }, }, } }, ) } Register tool and start server examples/simple_great_tool/main.go\rfunc main() { app. NewBuilder(). // adding the tool to the app WithTool(NewGreatTool). // setting up server WithName(\"great-tool-server\"). WithVersion(\"0.0.1\"). WithTransport(stdio.NewTransport()). // Configuring fx logging to only show errors WithFxOptions( fx.Provide(func() *zap.Logger { cfg := zap.NewDevelopmentConfig() cfg.Level.SetLevel(zap.ErrorLevel) logger, _ := cfg.Build() return logger }), fx.Option(fx.WithLogger( func(logger *zap.Logger) fxevent.Logger { return \u0026fxevent.ZapLogger{Logger: logger} }, )), ).Run() } Using toolinput package In order to define input schema for your tool, you can use toolinput package. It allows you to define input schema and validate arriving input.\nHere is an example of creating schema, giving it to the tool and validating input:\nexamples/simple_great_tool/main.go\rschema := toolinput.NewToolInputSchema( toolinput.WithString(\"kubeconfig\", \"Path to kubeconfig file\"), ) // Here we define a tool that lists k8s contexts using client-go return fxctx.NewTool( // This information about the tool would be used when it is listed: \u0026mcp.Tool{ Name: \"list-k8s-contexts\", Description: Ptr(\"List Kubernetes contexts from configuration files such as kubeconfig\"), InputSchema: schema.GetMcpToolInputSchema(), }, // This is the callback that would be executed when the tool is called: func(_ context.Context, args map[string]interface{}) *mcp.CallToolResult { input, err := schema.Validate(args) if err != nil { log.Printf(\"failed to validate input: %v\", err) return \u0026mcp.CallToolResult{ IsError: Ptr(true), Content: []interface{}{ mcp.TextContent{ Type: \"text\", Text: fmt.Sprintf(\"failed to validate input: %v\", err), }, }, } } path := input.StringOr(\"kubeconfig\", \"\") if path != \"\" { os.Setenv(\"KUBECONFIG\", path) } Examples Check out complete examples of MCP Servers with tools:\nlist_current_dir_files_tool list_k8s_contexts_tool ","newtool#NewTool":"","register-tool-and-start-server#Register tool and start server":"","using-toolinput-package#Using toolinput package":""},"title":"Tools"}}